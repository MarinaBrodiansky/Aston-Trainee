//Порешать типовые задачи - написать порядок и вывод в консоли):
// 1)
console.log('1');
setTimeout(() => console.log('2'), 1);
let promiseNew = new Promise((resolve) => {
console.log('3');
resolve();
});
promiseNew.then(() => console.log('4'));
setTimeout(() => console.log('5'));
console.log('6');
// порядок вывода в консоль - 1, 3, 6, 4, 2, 5
//console.log('1') - выполнится синхронно, первым, выведет 1
//setTimeout(() => console.log('2'), 1) - далее он натыкается на задачу установки таймера - просит браузерный API дать ему выполнить задачу через время установленное в таймере и дальше идет выполнять синхронные операции. Это макрозадача
//let promiseNew = new Promise((resolve) => {
//console.log('3');
//resolve();
//}); - далее создается промис, внутри которого обычный синхронный код, немедленно выводится 3, промис завершается
//promiseNew.then(() => console.log('4')) - добавляет коллбэк-функцию в очередь микрозадач после успешного выполнения промиса. Это микрозадача
//setTimeout(() => console.log('5')) - снова натыкается на задачу установки таймера, см п2
//console.log('6') -видит синхронный код - выводит в консоль
//завершив выполнение синхронного кода, начинает выполнять микрозадачи, она одна - коллбэк функция. Выводится 4
//далее переходит к макрозадачам. сначала выводит 2, потом 5. Несмотря на то что у 5 таймер равен 0, он все равно выведется позже 2, потому что 2 раньше попала в очередь макрозалач и таймер у 2 ничтожно мал

//2)
let promiseTree = new Promise((resolve, reject) => {
    resolve("a");
    console.log("1");
    setTimeout(() => {
    console.log("2");
    }, 0);
    console.log("3");
});
//порядок вывода в консоль - 1, 3, 2
//Промис создается и немедленно разрешается, 
//console.log("1") - выводит 1, это синхронный код
//setTimeout(() => {
    //console.log("2");
//}, 0) - натыкается на задачу установки таймера - просит браузерный API дать ему выполнить задачу через время установленное в таймере, даже несмотря на то, что там 0 и дальше идет выполнять синхронные операции. Это макрозадача
//console.log("3") - выводит 3, это синхронный код
//когда стэк синхронных задач пустой, движок смотрит на микрозадачи - их нет, после чего он выполняет макрозадачу - выводит 2

//3)
let promiseTwo = new Promise((resolve, reject) => {
    resolve("a");
});
    promiseTwo
    .then((res) => {
    return res + "b";
    })
    .then((res) => {
    return res + "с";
    })
    .finally((res) => {
    return res + "!!!!!!!";
    })
    .catch((res) => {
    return res + "d";
    })
    .then((res) => {
    console.log(res);
    });
//let promiseTwo = new Promise((resolve, reject) => {
//    resolve("a");
//}) - создается новый промис, который сразу же разрешется со значением "a"
//    promiseTwo
//    .then((res) => {
//    return res + "b";
//    }) - к значению "a" из предыдущего промиса добавляется "b" и возвращается "ab"
//    .then((res) => {
//    return res + "с";
//    }) - к значению "ab" из предыдущего блока добавляется "c" и возвращается "abc"
//    .finally((res) => {
//    return res + "!!!!!!!";
//    }) - ловушечка, видимо) не получает аргументов из предыдущего .then и нет необходимости передавать дальше
//    .catch((res) => {
//    return res + "d";
//    }) - ошибок нет, этот блок будет пропущен
//    .then((res) => {
//    console.log(res);
//    }) - значение "abc" из предыдущего .then передается колбэку и выводит в консоль "abc"

//4.
function doSmth() {
    return Promise.resolve("123");
}
    doSmth()
    .then(function (a) {
    console.log("1", a); //
    return a;
    })
    .then(function (b) {
    console.log("2", b);
    
    return Promise.reject("321");
    })
    .catch(function (err) {
    console.log("3", err);
    })
    .then(function (c) {
    console.log("4", c);
    return c;
    });
//в консоль выведется 
//1 123
//2 123
//3 321
//4 undefined
//function doSmth() {
//return Promise.resolve("123");
//} - вызывается функция, которая возвращает ращрешенный промис со значением 123
//doSmth()
//.then(function (a) {
//    console.log("1", a); //
//    return a;
//}) - передается значение 123 из разрешенного промиса, в консоли будет 1 123
//    .then(function (b) {
//    console.log("2", b); - значение проваливется из предыдущего .then в консль выводится 2 123
//    
//    return Promise.reject("321");
//    }) - создается и отклоняется новый промис со значением 321
//    .catch(function (err) {
//    console.log("3", err);
//    }) - передается значение из отклоненного промиса, в консоль выводится 3 321
//    .then(function (c) {
//    console.log("4", c);
//    return c;
//    }); - предыдущий блок ничего не передает, значит тут в параметре undefined, в консоль выводится 4 undefined

//5)
console.log("1");
setTimeout(function () {
console.log("2");
}, 0);
Promise.resolve().then(() => console.log("3"));
console.log("4");
//в консоль выведется 1432
//console.log("1") - синхронны код, исполнится сразу же. выведет 1 в консоль
//setTimeout(function () {
//console.log("2");
//}, 0) - движок натыкается на таймер, просит браузерное API дать ему задачу через время в таймере. Это макротаска
//Promise.resolve().then(() => console.log("3")) - создается и разрешается промис, добавляет колбэк в очередь микротасок
//console.log("4") - синхронный код, выведет 4
//после выполнения синхронного кода когда колл стэк пуст, идет выполнять микротаску, выводит 3, затем макротаску - выводит 2

//6)Напишите функцию, которая будет проходить через массив целых чисел и выводить индекс каждого
//элемента с задержкой в 3 секунды.
function showArrayWithDelay(array) {
    array.forEach((el, i) => {
      setTimeout(() => {
        console.log(i);
      }, 3000 * (i + 1));
    });
  }
  
  const list = [10, 12, 15, 21];
  showArrayWithDelay(list);


